*{
    font-weight: bold;
}
body{
    font-size: 18px;
    text-align: center;
    border: 2px dotted black;
}
h1{
    background-color: red;
    color: pink;
}
article>p{
    color: black;
}
#first, #second{
    color: red;
}
.orange{
    color: orange;
}
p:hover{
    color: orange;
}

/* 
vw - view width - works absolute - works acc. to width of browser screen
% - works relative to parent
px - works absolute - will be visible same in all sizes
em - relative to parent - also relative to font size defined in browser
rem - relative to root(html tag)

use rem with font-size
never use absolute size in font size
1 rem = 16px;

*/

*{
    /* padding: 0; */
    margin: 0;
    box-sizing: border-box; 
    /* this will not include padding and borders to the width and height of every element */
}

.box-model{
    width: 200px;
    height: 200px;
    border: 20px solid red;
    border-radius: 5px;
    padding: 10px 20px;
    margin: 10px 5px 10px 5px;
    /* top right bottom left */
}

ul{
    font-size: 2rem;
    background-color: black;
    color: wheat;
    text-align: end;
    /* padding: 10px; */
}
li{
    display: inline-block;
    padding: 10px;
    cursor: pointer;
}

li:hover{
    color: blueviolet;

}

/* ul,li,p,div, h1 - are block level element, they take whole width of html
to make them come in one line we have to use display: inline or display: inline-block */

/* span, a - are inline elements - they don't take width,height
to make them come in next line we have to use display: block
inline elements - only take horizontal space(padding, margin), not take vertical space
*/

/* img - is inline-block element - they take width,height
inline-block elements - take both horizontal space(padding, margin) and verticle space */


.container{
    width: 500px;
    height: 800px;
    margin: 100px;
    color: white;
    background-color: burlywood;
}
.blue{
    width: 100px;
    height: 100px;
    background-color: blue;
    position: relative; 
    /* this is relative to its parent */
    top: 100px;
    left: 100px;
}
.green{
    width: 100px;
    height: 100px;
    background-color: green;
    position: absolute;
    /* absolute is dependent to its nearby relative parent, if relative parent not found then root */
    top: 500px;
    left: 500px;
}
.red{
    width: 100px;
    height: 100px;
    background-color: red;
    position: fixed;
    /* it will fix the element, no effect on scroll */
    top: 0;
    left: 0;
}
.purple{
    width: 100px;
    height: 100px;
    background-color: purple;
    position: sticky;
    /* it will fix the element till the height of its parent is on screen */
    top: 20px;
}
.scroll{
    height: 70vh;
}

/* Without position: relative, the top property won't have any effect, 
and the paragraph will remain in its default position */

/* When an element has a fixed position, it is taken out of the normal 
flow of the document and positioned relative to the browser window. 
This means that other elements will not be aware of its presence and will not be affected by it.

In the given HTML and CSS code, the nav element has a fixed position, 
so it is displayed at the top of the viewport. The paragraph inside the main element 
is not aware of the nav element's position and behaves as if the nav element is not there. 
That's why the paragraph appears below the div that contains the nav element. */

/* position property is static bydefault */


/* overflow - by default visible
scroll - x, y scroller
auto - scroll where required */

/* float - left, right, none, inhert */
/* clear - it clears float from left, right and both */
/* only use clear and float for img, text */
/* if one is given float then other element will find space after it */


/* margin: 0 auto; - vertically 0 and horizontally in center of parent */
/* position: relative, top: 50%, tranform: translateY(-50%) */

/* margin-inline: auto - give margin from left and right */
/* margin-block: 10px - give from top and bottom */

/* background-size: 10px, background-repeat: no-repeat - by-default it is repeating */
/* background-postition: center; */

/* in order to center a div make a outer div first and make it have full width
and height and them center div using above properties */

/* .signup-header h1: This selector targets any <h1> element that is a descendant 
of an element with the class "signup-header". It will select all <h1> elements 
inside the "signup-header" class, regardless of their direct parent-child relationship.

.signup-header > h1: This selector targets only the <h1> elements that are an 
immediate child of an element with the class "signup-header". 
It will select <h1> elements that are directly nested within the "signup-header" class. */

/* background: linear-gradient(to top left, #ffffffff, #ffffff33)
to top left is the direction of the gradient. It means that the gradient will start from the bottom 
right corner and gradually transition towards the top left corner.

#ffffffff: This is a hexadecimal color value #ffffffff, 
which represents the color white with full opacity (fully opaque). It is the starting color of the gradient.

#ffffff33: This is a hexadecimal color value #ffffff33, which represents the color 
white with an alpha value of 0.33. The alpha value defines the transparency of the color, 
where 1.0 is fully opaque and 0.0 is fully transparent. In this case, 
the alpha value 0.33 makes the color slightly transparent. It is the ending color of the gradient. */

/* 
The CSS backdrop-filter property allows you to apply graphical effects to the area behind an element, 
including blurring, color shifting, and more. In this case, the backdrop-filter 
property is set to blur(8px), which applies a blur effect to the backdrop. */


/* for making flex box we need parent div.
we use display:flex to make a div flex box */
/* in flex-box = we have main-axis (horizontally) and cross-axis (vertically) */
/* display: flex = by-default - horizontal that is flex-direction: row */

/* to make flex-box vertically flexed we use flex-direction: column */

/* we have main-container and child-container in flex
properties for main container are:-
1. flex-direction:row-reverse, column-reverse, row, column
2. flex-wrap: wrap, wrap-reverse - it wraps if screen becomes small
3. gap:10px - it only give gap b/w childeren not b/w child & parent
4. row-gap: 10px - gap only b/w rows
5. column-gap: 10px
6. flex-flow: wrap row - it is combination of flex-wrap & flex-direction
7. we use justify-content to align the items on main axis(horizontally)
        justify-content: space-around - it distribute remaining space b/w children
        justify-content:space-between - only distribute b/w children not child to parent
        justify-content:space-evenly - it will have evenly space
        justify-content:flex-start - all move to start(it is by-default)
        justify-content:flex-end - all move to end
        justify-content: center - move to center
8. we use align-items to align items on cross-axis(vertically)
        align-item: stretch - it stretches vertically to take whole space(by-default)
        align-item: center - aligns to center vertically
        align-item: flex-start, flex-end
9. we use align-content for distance b/w two rows = by-default it is stretch
        align-content: flex-start - start from above
        align-content: space-between, space-evenly

properties for child container are:-
1. order: 2 - it means that particular child will less order and move to :end
2. flex-grow: 1 - that particular child will grow and take more space(by-default-0)
3. flex-shrink: 2 - that particular child will shrink more(by-default-1)
4. flex-basis: 400px - that particular child will have width by default more than others
5. flex: 0 0 400px - combination of flex-grow,  flex-shrink and flex-basis
6. align-self: flex-start, stretch - align itself irrrespective of other children */


.main-container{
    display: flex;
    flex-direction:row;
    border: 2px solid black;
    height: 50vh;
    justify-content: space-evenly;
    flex-wrap: wrap;
    align-items:stretch;
    align-content: stretch;
}
.box1{
    border: 2px solid black;
    width: 160px;
    flex-basis: 300px;
    align-self:flex-start;
}
.box2{
    border: 2px solid black;
    width: 160px;
    flex-grow: 1;
}
.box3{
    border: 2px solid black;
    width: 160px;
}
.box4{
    border: 2px solid black;
    width: 160px;
}
.box5{
    border: 2px solid black;
    width: 160px;
}
.box6{
    border: 2px solid black;
    width: 160px;
}


/* ways for making variables in css

:root {
    --primary-text-color: #183b56;
    --secondary-text-color: #577592;
}

body {
    color: var(--primary-text-color);
} */


/* transition: 0.2s ease-out */
/* box-shadow: 0 0 2px #abds90 - x direction y direction blur */

/* .box:nth-child(2) = apply css for 3rd child */


.top-div{
    width: 500px;
    height: 500px;
    background-color: red;
    position: relative;
}
.child-div{
    position: absolute;
    bottom:20px;
}


/* css - grid

if we want to make anything in grid then we have grid container and set its property
to display: grid
parent container properties:-
1. gap: 10px - gap between rows
2. row-gap, column-gap
3. grid-template-columns: 1fr 2fr 1fr 1fr = we will have 4 columns here, we can have as
        many columns depends on our property in the given screen size.
   grid-template-columns: repeat(4, 1fr) = here 4 times 1fr size columns will be repeated.
   grid-template-columns: repeat(auto-fill, 1fr) = here columns will autofill in given screen size
   this is recommended much as it can be achieved by flex
   grid-template-columns: 200px auto = first column 200px then last will take whatever width remained
4. grid-template-rows: 200px 80px = first row will be of 200px height and second of 80px height
5. grid-auto-rows: 200px = for those rows whose height we haven't defined will get 200px height
6. justify-content: center = this will center columns in between = works horizontally(x-axis)
7. align-content: center = this will center rows in between = works vertically(y-axis)
8. align-items: center = this will center the items present in the div.

for grids = align-items applies to Grid items, not the Grid container while align-content 
    controls how grid items are aligned in the grid container vertically


child container properties:-
1. justify-self: start = move that particular child to start horizontally = by-default it is stretch
2. align-self: start = move that particular child to start vertically
3. grid-column-start: 1, grid-column-end: 4 = that particular child will take space of 3 columns = take space from 1st till 3rd index
  or grid-column: 1 / 4
  or grid-column: 1 / span 3
  grid-column: 1 / -1 = take space from 1 till -1 = it will take all columns present in that row
4. grid-row: 1 / 4 = that particular child will take space of 3 rows
  or grid-row: 1 / span 3
5. grid-area: 1/ 1/ 3/ 3 = row start from 1 and end at 3, column start from 1 and end at 3  


in parent container
grid-template-areas: "hdr hdr hdr hdr"
                     "sbr main main main"
                     "sbr main main main"
                     "ftr ftr ftr ftr"
in child
.box1{ grid-area: hdr; }
.box2{ grid-area: sbr; }
.box3{ grid-area: main; }
.box4{ grid-area: ftr; } */


.grid-container{
    display: grid;
    row-gap: 10px;
    column-gap: 10px;
    /* grid-template-columns: 100px 200px 100px; */
    /* grid-template-columns: 200px auto; */
    /* grid-template-columns: 1fr 2fr 1fr; */
    grid-template-columns: repeat(3, 1fr);
    /* grid-template-columns: repeat(auto-fill, 1fr); */
    grid-template-rows: 180px 80px;
    grid-auto-rows: 140px;
    /* justify-content: center; */
    /* align-items: center; */
    /* align-content: center; */
}
.box{
    border: 2px solid black;
    padding: 15px;
}
#box1{
    /* justify-self: start; */
    /* align-self:center; */
    /* grid-column-start: 2; grid-column-end: 4; */
    /* grid-column: 1/3; */
    /* grid-column: 1/span 2; */
    /* grid-column: 1/-1;
    grid-row: 2/4; */
    grid-area: 1/ 1/ 3/ 3;
}

.grid-temp-container{
    display: grid;
    grid-template-areas: "hdr hdr hdr hdr"
                     "sbr main main main"
                     "ftr ftr ftr ftr";
}
#box1-temp{
    grid-area: hdr;
}
#box2-temp{
    grid-area: sbr;
}
#box3-temp{
    grid-area: main;
}
#box4-temp{
    grid-area: ftr;
}

/* media queries */
/* take min-width as stating from
take max-width as till
starting from 400px and till 600px apply below property */
@media (min-width: 400px) and (max-width: 600px) {
    body{
        background-color: cadetblue;
    }
}
/* or */
@media (400px <= width <= 600px) {
    body{
        background-color: cadetblue;
    }
}

/* it is just reducing 50% by 10px */

/* width: calc(50% - 10px); */


/* pseudo class - it is used to define a special state of an element

:link - normal initial state of button
:visited - visited state of button
:active - this is after click property of button
ul li:first-child - this will select first li child of ul
ul li:last-child - select last child
ul li:nth-child(4) - select 4th child
ul li:nth-child(2n) - all even child
:nth-child(2n+1) */

/* pseudo elements - it selects specified part of an element

h2::first-letter - only first letter of h2 will be selected
h2::first-line - selects only first line
::selection - this will change selection of that page

h2::before - so anything before h2 tag will be selected - this before will not present in dom
h2::before{
    content: 'any';
}
h2::after{
    content: '*';
}

we use ::before and ::after in forms for required fields */

.learn:link{
    color: red;
    background-color: blue;
    padding: 20px;
}
.learn:visited{
    color: yellow;
}
.learn:hover{
    border: 2px solid black;
}
.learn:active{
    border: 4px solid brown;
}

/* ul li:first-child{
    background-color: red;
}
ul li:last-child{
    background-color: blue;
}
ul li:nth-child(4){
    background-color: tomato;
}
ul li:nth-child(2n+1){
    color: violet;
}
h2::first-letter{
    color: red;
}
h2::first-line{
    color: indigo;
}
::selection{
    color: yellow;
    background-color: tomato;
}
h2::before{
    content: 'any';
}
h2::after{
    content: '*';
} */


/* transform property = applies a 2d or 3d animation to an element, how to move from point to point b

transform: scale(2); = it will increase the size in x and y direction by 2times
transform: scaleX(2) scaleY(1.5); = it will increase the size in x direction by 2times and  1.5 in y direction
transform: scaleZ(2) = towards z direction
transform: scaleX(2, 1.5) = x and y

transform: skew(2, 1.5) = rotate in x and y direction

tranform: translate(20px, 40px) = it will move relative to the parent in x and y direction
tranform: translate(50%, 50%) = this will move content to center from x and y direction

tranform: rotate(45deg) = bydefault rotate in z direction
tranform: rotateX(45deg) = rotate in X

can apply all above properties together also

tranform-orgin = using this we can define the origin from where we want to apply scale, skew, translate, rotate
tranform-orgin: top;
tranform-orgin: 50% 50% = center = this is by-default value = so apply all property from center


transition-duration: 1s = take 1 second to apply
transition-property = on which property we want transition to be applied = by-default = all = all is not prefered to be applied as to take more computation
transition-property: border-radius;
transition-delay: 1s = take delay of 1s to apply transition
transition-timing-function = tell about how we are moving from a point to b point
transition-timing-function: ease = specifies transition effect with slow start, then fast, then end slowly(by-default)
transition-timing-function: ease-in = starts slow
transition-timing-function: ease-out = ends slow
transition-timing-function: linear
transition-timing-function: cubic-bezier(n,n) = we can define our own value in this

animation-name: circles;
animation-duration: 4s;
animation-delay: 2s;
animation-iteration-count: infinite;
animation-direction: reverse; = we have alternate, alternate-reverse
animation-timing-function: linear
animation-fill-mode: forward = it will stop where we have 100% = by-default none
animation-fill-mode: backward

animation = it is shorthand for all above properties
@keyframes circles {
    0%, 100% {
        transform: translate(0,0);
    }
    25% {
        transform: translate(200px,0);
    }
    50% {
        transform: translate(200px,200px);
    }
    75% {
        transform: translate(0,200px);
    }
}
using from and to for 0 and 100 */
